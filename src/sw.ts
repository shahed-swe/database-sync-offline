/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';

declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = 'offline-first-v1';
const API_CACHE_NAME = 'api-cache-v1';

// Precache static assets generated by Vite
cleanupOutdatedCaches();
precacheAndRoute(self.__WB_MANIFEST);

/**
 * Install event - cache static assets
 */
self.addEventListener('install', (event: ExtendableEvent) => {
  console.log('[SW] Installing service worker...');
  
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[SW] Caching static assets');
      return cache.addAll([
        '/',
        '/index.html',
      ]);
    }).then(() => {
      // Force the waiting service worker to become the active service worker
      return self.skipWaiting();
    })
  );
});

/**
 * Activate event - clean up old caches
 */
self.addEventListener('activate', (event: ExtendableEvent) => {
  console.log('[SW] Activating service worker...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME && cacheName !== API_CACHE_NAME) {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      // Claim all clients immediately
      return self.clients.claim();
    })
  );
});

/**
 * Fetch event - serve from cache when offline, network when online
 */
self.addEventListener('fetch', (event: FetchEvent) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-http(s) schemes (chrome-extension, etc.)
  if (!url.protocol.startsWith('http')) {
    return;
  }

  // Handle API requests differently
  if (url.pathname.startsWith('/api/')) {
    // For API requests, try network first, then cache
    event.respondWith(
      fetch(request)
        .then((response) => {
          // Clone the response before caching
          const responseClone = response.clone();
          caches.open(API_CACHE_NAME).then((cache) => {
            // Only cache http(s) requests
            if (request.url.startsWith('http')) {
              cache.put(request, responseClone);
            }
          });
          return response;
        })
        .catch(() => {
          // If network fails, try cache
          return caches.match(request).then((cachedResponse) => {
            if (cachedResponse) {
              return cachedResponse;
            }
            // Return a custom offline response
            return new Response(
              JSON.stringify({ error: 'Offline', offline: true }),
              {
                headers: { 'Content-Type': 'application/json' },
                status: 503,
              }
            );
          });
        })
    );
  } else {
    // For static assets, try cache first, then network
    event.respondWith(
      caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }
        return fetch(request).then((response) => {
          // Cache the new resource for future offline use
          if (request.method === 'GET') {
            const responseClone = response.clone();
            caches.open(CACHE_NAME).then((cache) => {
              // Only cache http(s) requests
              if (request.url.startsWith('http')) {
                cache.put(request, responseClone);
              }
            });
          }
          return response;
        });
      })
    );
  }
});

/**
 * Background Sync event - sync unsynced posts
 */
self.addEventListener('sync', (event: any) => {
  console.log('[SW] Sync event triggered:', event.tag);

  if (event.tag === 'sync-posts') {
    event.waitUntil(syncPosts());
  }
});

/**
 * Sync all unsynced posts to the backend
 */
async function syncPosts(): Promise<void> {
  console.log('[SW] Starting background sync...');

  try {
    // Import Dexie dynamically in the service worker
    const { db } = await import('./utils/db');
    
    // Get all unsynced posts
    const unsyncedPosts = await db.posts.where('synced').equals(0).toArray();
    
    if (unsyncedPosts.length === 0) {
      console.log('[SW] No posts to sync');
      return;
    }

    console.log(`[SW] Syncing ${unsyncedPosts.length} posts...`);

    const API_BASE_URL = 'http://localhost:3001';

    // Sync each post
    const syncPromises = unsyncedPosts.map(async (post) => {
      try {
        const response = await fetch(`${API_BASE_URL}/api/posts`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            id: post.id,
            title: post.title,
            description: post.description,
            createdAt: post.createdAt,
          }),
        });

        if (response.ok) {
          // Mark as synced
          await db.posts.update(post.id, { synced: 1 });
          console.log('[SW] Post synced successfully:', post.id);
          
          // Notify all clients about the sync
          await notifyClients({ type: 'POST_SYNCED', postId: post.id });
        } else {
          console.error('[SW] Failed to sync post:', post.id, response.status);
          // Update sync attempt count
          await db.posts.update(post.id, {
            syncAttempts: (post.syncAttempts || 0) + 1,
            lastSyncAttempt: Date.now(),
          });
        }
      } catch (error) {
        console.error('[SW] Error syncing post:', post.id, error);
        // Update sync attempt count
        await db.posts.update(post.id, {
          syncAttempts: (post.syncAttempts || 0) + 1,
          lastSyncAttempt: Date.now(),
        });
      }
    });

    await Promise.all(syncPromises);
    console.log('[SW] Background sync completed');
  } catch (error) {
    console.error('[SW] Error during background sync:', error);
    throw error; // Rethrow to retry sync later
  }
}

/**
 * Notify all clients about sync status
 */
async function notifyClients(message: any): Promise<void> {
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach((client) => {
    client.postMessage(message);
  });
}

/**
 * Message event - handle messages from clients
 */
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  console.log('[SW] Message received:', event.data);

  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'SYNC_NOW') {
    // Trigger immediate sync
    event.waitUntil(syncPosts());
  }
});

// Export empty object to make this a module
export {};
